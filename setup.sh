#! /usr/bin/env nix-shell
#! nix-shell -i bash --packages git sops nebula cryptsetup headscale
set -e

hostname=""
luksDevice="/dev/disk/by-uuid/d52694cc-e7b0-4b7e-b638-8251d8609b9e"
luksNebulaPath="nebula"
nebulaDomain="nb.honermann.info"
remote="server"
remote_sock="/run/headscale/headscale.sock"
local_sock="/tmp/headscale-tunnel.sock"
sops_file="secrets/tailscale.yaml"


sshKeys() {
    mkdir -p secrets/$hostname

    ed25519key=/tmp/ed25519
    rsakey=/tmp/rsa

    ssh-keygen -t ed25519 -N "" -f $ed25519key
    ssh-keygen -t rsa -N "" -f $rsakey
    echo $ed25519key
    echo $rsakey
    printf "ssh_host_ed25519_key: |+\n$(awk '{print "    " $0}' ${ed25519key})\nssh_host_rsa_key: |+\n$(awk '{print "    " $0}' $rsakey)\n" > ./secrets/$hostname/sshd.yaml
    rm $ed25519key $rsakey
    sops -i -e secrets/$hostname/sshd.yaml
    git add secrets/$hostname/sshd.yaml
    git commit -o secrets/$hostname/sshd.yaml -m "$hostname: Added ssh hostkeys for $hostname"
}

updateNebula() {

    openLuks

    for path in secrets/*; do
        echo "$path"
        hostname="${path##*/}"
        if [ -f "/mnt/${luksNebulaPath}/${hostname}.${nebulaDomain}.crt" ]; then
            printNebulaYAML "$hostname"
            sops -i -e "secrets/$hostname/nebula.yaml"
        fi
    done

    closeLuks

    git add secrets
    git commit -o secrets -m "nebula: Updated all nebula certs"

}

addNebulaHost() {
    openLuks
    /mnt/${luksNebulaPath}/create.sh "$hostname" "$groups"
    printNebulaYAML "$hostname"
    filepath="secrets/$hostname/nebula.yaml"
    sops -i -e "$filepath"
    closeLuks

    git add "$filepath"
    git commit -o "$filepath" -m "nebula: Add Host $hostname"
}

printNebulaYAML() {
    mkdir -p ./secrets/$1
    printf "nebula:\n    $1.key: |\n$(awk '{print "        " $0}' /mnt/${luksNebulaPath}/${1}.${nebulaDomain}.key)\n    $1.crt: |\n$(awk '{print "        " $0}' /mnt/${luksNebulaPath}/${1}.${nebulaDomain}.crt)\n" > "secrets/$1/nebula.yaml"
}

openLuks() {
    sudo cryptsetup open $luksDevice luksUSBDeviceNebula
    sudo mount /dev/mapper/luksUSBDeviceNebula /mnt

}

closeLuks() {
    #umount and lock usb stick (try again if still busy)
    until sudo umount /mnt; do
        sleep 1
    done
    until sudo cryptsetup close /dev/mapper/luksUSBDeviceNebula; do
        sleep 1
    done

}


updateTailscale() {
    # Remove leftover socket file if needed
    rm -f "${local_sock}"

    # Start SSH tunnel in background
    ssh -o ExitOnForwardFailure=yes \
        -o StreamLocalBindUnlink=yes \
        -o ServerAliveInterval=30 -o ServerAliveCountMax=3 \
        -N -L "${local_sock}:${remote_sock}" "${remote}" &
    local ssh_pid=$!

    # Define cleanup
    cleanup() {
        kill "${ssh_pid}" 2>/dev/null || true
        wait "${ssh_pid}" 2>/dev/null || true
        rm -f "${local_sock}"
        trap - RETURN SIGINT SIGTERM
    }

    # Trap on function return, Ctrl-C, and termination
    trap cleanup RETURN SIGINT SIGTERM

    # Wait for the local socket to appear (timeout 5s)
    local timeout=5
    for ((i=0; i<timeout*10; i++)); do
        [[ -S "${local_sock}" ]] && break
        sleep 0.1
    done

    if [[ ! -S "${local_sock}" ]]; then
        echo "Failed to create local socket ${local_sock}" >&2
        cleanup
        return 1
    fi

    echo "Tunnel ready at ${local_sock}"

    # Set configfile
    HEADSCALE_CONFIG=./config.yaml

    # Fetch user list
    local headscaleusers=( $(headscale users list -o yaml | sed -nE 's/( +name: )(.*)/\2/p') )

    # Detect "-h" in additional args
    show_only=false
    for arg in "$@"; do
        if [ "$arg" = "-h" ]; then
            show_only=true
            break
        fi
    done

    printf "Fetched %d users from headscale\n" "${#headscaleusers[@]}"

    # Generate new auth keys and write them all to one SOPS file
    for long_user in "${headscaleusers[@]}"; do
        short_user="${long_user%@account.honermann.info}"
        echo "Creating auth key for user: ${short_user}"
        echo "additional args: $@"

        # Generate a reusable preauth key
        auth_output=$(headscale preauthkeys create --reusable -u "${long_user}" "$@")

        if [ "$show_only" = true ]; then
            echo -e "headscale Help:\n\n"
            echo "$auth_output"
            return 0  # or exit 0 if not in a function
        fi

        # Write or update the key entry in secrets/tailscale.yaml
        sops --set "[\"${short_user}-auth-key\"] \"${auth_output}\"" "${sops_file}"

        echo "Updated ${sops_file} with ${short_user}-auth-key"
    done
}

printHelp() {
    echo Usage:
    echo    ./setup.sh sshKeys \<hostname\>
    echo    ./setup.sh updateNebula
    echo    ./setup.sh addNebula \<hostname\> \<groups\> \#The IP gets autogenerated
    echo    ./setup.sh tailscale [-e 10m] \#all other params are passed to the headscale command see -h
}

cd $(dirname "$0")
pwd
case $1 in
    sshKeys)
        hostname=$2
        sshKeys
        exit 0
        ;;
    updateNebula)
        updateNebula
        exit 0
        ;;
    addNebula)
        hostname=$2
        groups=$3
        addNebulaHost
        exit 0
        ;;
    tailscale)
        updateTailscale "${@:2}"
        exit 0
        ;;
    *)
        echo Unknown Command
        printHelp
        exit 1
        ;;
esac
